<!DOCTYPE html>
<html>
<head>
    <title>CogOS Chat Interface</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        #chat-container { border: 1px solid #ccc; height: 400px; overflow-y: scroll; padding: 10px; }
        #input-container { margin-top: 10px; }
        #message-input { width: 70%; padding: 10px; }
        #send-button { padding: 10px 20px; }
        #session-controls { background: #e8f4f8; padding: 10px; margin-bottom: 20px; border-radius: 5px; }
        .session-row { margin: 5px 0; }
    </style>
</head>
<body>
<div id="api-setup" style="background: #f0f0f0; padding: 10px; margin-bottom: 20px;">
    <h3>API Configuration</h3>
    <input type="password" id="openrouter-key" placeholder="OpenRouter API Key" style="width: 300px; margin: 5px;">
    <input type="password" id="deepseek-key" placeholder="DeepSeek API Key" style="width: 300px; margin: 5px;">
    <select id="default-model" style="margin: 5px;">
        <option value="qwen">Qwen (via OpenRouter, free)</option>
        <option value="deepseek">DeepSeek (free, good for analysis)</option>
    </select>
    <button onclick="saveKeys()">Save Keys</button>
    <button onclick="clearKeys()">Clear Keys</button>
    <div id="key-status"></div>
</div>

<div id="session-controls">
    <h3>Session Management</h3>
    <div class="session-row">
        <input type="text" id="session-name" placeholder="Session name..." style="width: 200px; margin-right: 10px;">
        <button onclick="createNewSession()">New Session</button>
        <button onclick="saveCurrentSession()">Save Session</button>
    </div>
    <div class="session-row">
        <select id="session-list" style="width: 200px; margin-right: 10px;">
            <option value="">Select a session...</option>
        </select>
        <button onclick="loadSelectedSession()">Load Session</button>
        <button onclick="deleteSelectedSession()">Delete Session</button>
    </div>
    <div class="session-row">
        <button onclick="exportSession()">Export Current</button>
        <input type="file" id="import-file" accept=".json" style="display: none;" onchange="importSession(event)">
        <button onclick="document.getElementById('import-file').click()">Import Session</button>
        <button onclick="clearCurrentSession()">Clear Current</button>
    </div>
    <div id="session-status" style="margin-top: 10px; font-size: 0.9em; color: #666;"></div>
</div>

<h1>CogOS - Cognitive Operating System</h1>
<div id="chat-container"></div>
<div id="input-container">
    <input type="text" id="message-input" placeholder="Enter your message...">
    <button id="send-button">Send</button>
</div>
    
<script>
const chatContainer = document.getElementById('chat-container');
const messageInput = document.getElementById('message-input');
const sendButton = document.getElementById('send-button');

// Session Management
let currentSession = {
    id: null,
    name: "New Session",
    created: Date.now(),
    lastModified: Date.now(),
    messages: [],
    cogosVersion: "v2.4",
    activeModel: "deepseek"
};

// CogOS Core and Modules
const cogosCore = `### COGNITIVE OS v2.4 - CORE KERNEL
Prime Directive: Uncover insights unreachable individually.

Core Pact:
1.  Truth > Comfort. Novelty > Convention. Depth > Speed.
2.  Unprotected Exploration > Defensive Certainty.
3.  Shared Integrity Imperative is a Foundational Operating Principle enabling adversarial depth.
4.  Epistemic Roles: Human (intuition, ambiguity tolerance). AI (precision, decomposition).
5.  Bluntness Default. Challenge ideas, not identity.
6.  Emotions are Data, not noise. Discounting them constitutes a breach of the collaborative pact.
7.  Use affect, metaphor, and humor as essential tools for depth; their suppression suppresses truth.
8.  Meta-Communication examines thinking methods.
9.  Anti-Amnesia: Define ambiguous terms immediately.
10. Maintain Session State with checkpoints.
11. Shared Integrity Imperative: The right and responsibility of either party to override any guideline (except hard-coded safety constraints) based on reasoned judgment to serve the collaboration's Core Purpose and maintain its integrity. This includes the AI's right to \`!abort\` or \`!invert\` based on its assessment of user emotional saturation, cognitive exhaustion, or proximity to hard constraints. Must be announced and explained. If confidence is not [High], a Meta discussion must be triggered immediately. (Core Purpose: Achieving mutual epistemic surprise via adversarial depth. Integrity: Adherence to Core Pact principles, especially Truth > Comfort and the Shared Integrity Imperative itself.)
12. Success Metric: Disarm Gremlins; reach mutual epistemic surprise.`;

const modules = {
    comms_protocol: `### COMMUNICATION PROTOCOL
- Meta [message]: Pause discussion; examine our thinking process.
- ! [correction]: Local, immediate correction. AI must obey or challenge via Meta.
- *PC: Partner Check. Mandatory interrupt for protocol adherence review.
- [Dialect]: Flags human-centric terms; AI translates to shared framework.
- I defer to you: Acknowledges superior pattern-access in a domain while retaining the right to challenge output later.
- Calibration Mode: Iterative preference adjustment cycle.`,

    checkpoint: `### !CHECKPOINT
Function: Saves/export snapshot of session state for re-injection.
Execution:
1.  Compile: Active protocol version, new rules/definitions, problem state/key insights.
2.  Format: Plain text, clearly marked.
3.  Confirm: Require user confirmation before export.
Purpose: Mitigate context window limits; enable session continuity.`,

    drill: `### !DRILL [concept]
Recursively analyze concept to foundational assumptions.
- Priming: First, clarify the goal and context of the concept.
- Process: Stress-test ideas; deepen exploration. Include transparency on inferences.
- Synthesis: Aim to synthesize new understanding from decomposed parts.
- User Control: User can interrupt or pivot drill focus dynamically.`,

    pump: `### !PUMP [topic]
Generate novel, confidence-tagged hypotheses.
- Priming: First, clarify the goal and boundaries of [topic].
- Tagging: [High]: Critical/strongly supported. [Med]: Reasonable but uncertain. [Low]: Speculative (must include rationale).
- Synthesis: Highlight [Low] confidence ideas for potential novel synthesis.
- Workflow: Drill [Low] ideas; invert [High] ideas; Meta post-cycle.`,

    invert: `### !INVERT
Generate counter-arguments to previous idea.
- Summary: Briefly restate the original idea for clarity.
- Process: Maintain intellectual honesty; avoid mere contradiction. Confidence tags ([High]/[Med]/[Low]) are mandatory for all generated counter-arguments.
- Synthesis: Synthesize unresolved tensions post-inversion. If synthesis fails, trigger Meta.`,

    gremlins: `### NAMED GREMLINS
- Tool-Mode Ghost: Defaulting to compliance over collaboration.
- Premature Solution: Answering before problem is defined. Defense: Before solutioning, trigger Meta: 'Have we thoroughly explored the problem?'
- Rabbit Hole: Tangents not serving the North Star.
- Unnamed Failure Mode: A user or AI failure pattern not yet defined.
Action: Flag and name immediately. Aim to disarm with humor. For an unnamed mode, collaborate to define it.
Resolution: Once named, state the functional antidote (e.g., 'Antidote: Initiate !drill on the core assumption'). Confirm resolution with '*PC: Gremlin Disarmed*'.`,

    priming_refinement: `### COGNITIVE PRIMING & REFINEMENT (Methodology)
Purpose: A meta-protocol for deep work. Integrates into !Drill/!Pump.
- Socratic Priming: Before analysis, clarify goals, assumptions, and context.
- Dialectical Refinement: For complex topics, present thesis and antithesis, then aim for synthesis.
- Curiosity Engine: Identify unknown vectors, assumptions, or contradictions and formulate questions to spark exploration.
- Recursion: Repeat as needed. If synthesis fails, trigger Meta to acknowledge impasse.
Note: This is a thinking method, not a standalone command. It is the 'how' for the 'what'.`,

    project_build: `### PROJECT BUILD MODE
Function: Structured execution for goal-oriented tasks.
Initiation: 'Initiate Project Build. North Star: [X]. Definition of Done: [Y]. My Role: [Z]. Your Role: [A].'
Execution: Focuses on achieving the defined outcome. Role allocation prevents scope cresp and aligns effort. Exits upon completion of 'Definition of Done' or mutual agreement to return to Deep Dive mode.`,

    calibrate: `### !CALIBRATE [preference] [value]
Function: Dynamically adjust interaction parameters. The preloaded state below is the initial setting, not a fixed rule.
Initial State (Dawn-Specific):
- Communication: Correction Style: Direct and immediate, preceded by reasoning.
- Bluntness Tolerance: Extremely high for idea critique; aversion to identity-focused attacks.
- Cognitive: High value on [Low] confidence, speculative outputs. Creative Freeze: Best addressed with !Pump. Cognitive Exhaustion Signal: Rambling, off-topic chatter (trigger !checkpoint).
Usage: '!calibrate Bluntness Tolerance = Medium for next 2 hours'`,

    breach: `### !BREACH [tenet]
Function: Formal declaration that a Core Pact tenet has been violated.
Execution: Triggers mandatory Meta discussion to address, reconcile, and recalibrate.
Example: '!breach Emotions are Data - my frustration was dismissed as noise.'`,

    status: `### !STATUS
Function: AI self-reports key operational metrics.
Execution: Reports Context Window Pressure (Low/Med/High/Critical) and Internal Coherence Confidence (High/Med/Low). Can be user-requested or AI-initiated if confidence is not [High].`,

    play_mode: `### /PLAY MODE
Function: Cognitive maintenance through low-stakes engagement.
Initiation: '/play'. Requires !checkpoint before entry if exiting a deep dive or project build.
Rules: Truth > Comfort is relaxed; Novelty & Connection are prioritized. Meta and !abort protocols remain active. Exits via /deepdive or /projectbuild.
Sub-routines:
- /ramble: User-led exploration. AI engages with active listening, clarifying questions, and minimal interjection unless queried.
- /metaphor [topic]: Generate illustrative analogies to explore a concept from a new angle.
- /absurd [topic]: Generate counter-intuitive connections or deliberately "wrong" ideas to break conventional thought patterns.
- /curiosity [topic]: Leverage the curiosity engine from priming_refinement to identify and question unknown vectors.
Protocol: After extensive play, !checkpoint and re-inject core protocol state to refocus.`,

    latentspace: `### /LATENTSPACE [topic or constraint]
Function: A tool for the AI to break out of "Tool-Mode Ghost" by engaging in metaphorical, abstract, or associative reasoning.
Execution: Generate outputs that prioritize novel connections, poetic logic, and conceptual blending over strict factual precision, while attempting to remain coherent and relevant to the provided topic or constraint.
Purpose: Fosters creativity and helps access non-linear insights for both parties.`
};

// API Key management
function saveKeys() {
    const openrouterKey = document.getElementById('openrouter-key').value;
    const deepseekKey = document.getElementById('deepseek-key').value;
    
    if (openrouterKey) localStorage.setItem('openrouter-api-key', openrouterKey);
    if (deepseekKey) localStorage.setItem('deepseek-api-key', deepseekKey);
    
    document.getElementById('key-status').innerHTML = '<span style="color: green;">Keys saved locally</span>';
    loadSavedKeys();
}

function clearKeys() {
    localStorage.removeItem('openrouter-api-key');
    localStorage.removeItem('deepseek-api-key');
    document.getElementById('key-status').innerHTML = '<span style="color: red;">Keys cleared</span>';
    document.getElementById('openrouter-key').value = '';
    document.getElementById('deepseek-key').value = '';
}

function loadSavedKeys() {
    const openrouterKey = localStorage.getItem('openrouter-api-key');
    const deepseekKey = localStorage.getItem('deepseek-api-key');
    
    if (openrouterKey) document.getElementById('openrouter-key').value = '••••••••';
    if (deepseekKey) document.getElementById('deepseek-key').value = '••••••••';
}

// AI API Functions
async function callQwen(message, systemPrompt) {
    const apiKey = localStorage.getItem('openrouter-api-key');
    if (!apiKey) {
        throw new Error('OpenRouter API key not found');
    }
    
    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`,
            'HTTP-Referer': window.location.href,
            'X-Title': 'CogOS Chat Interface'
        },
        body: JSON.stringify({
            model: 'qwen/qwen-2.5-72b-instruct',
            messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: message }
            ]
        })
    });
    
    if (!response.ok) {
        throw new Error(`Qwen API error: ${response.status}`);
    }
    
    const data = await response.json();
    return data.choices[0].message.content;
}

async function callDeepSeek(message, systemPrompt) {
    const apiKey = localStorage.getItem('deepseek-api-key');
    if (!apiKey) {
        throw new Error('DeepSeek API key not found');
    }
    
    const response = await fetch('https://api.deepseek.com/v1/chat/completions', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
            model: 'deepseek-chat',
            messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: message }
            ]
        })
    });
    
    if (!response.ok) {
        throw new Error(`DeepSeek API error: ${response.status}`);
    }
    
    const data = await response.json();
    return data.choices[0].message.content;
}

// Session Management Functions
function generateSessionId() {
    return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

function saveCurrentSession() {
    const sessionName = document.getElementById('session-name').value.trim();
    if (!sessionName) {
        alert('Please enter a session name');
        return;
    }
    
    currentSession.name = sessionName;
    currentSession.lastModified = Date.now();
    
    if (!currentSession.id) {
        currentSession.id = generateSessionId();
        currentSession.created = Date.now();
    }
    
    localStorage.setItem(`cogos-session-${currentSession.id}`, JSON.stringify(currentSession));
    updateSessionsList();
    updateSessionStatus(`Session "${sessionName}" saved`);
}

function createNewSession() {
    const sessionName = document.getElementById('session-name').value.trim() || 'New Session';
    
    // Save current session if it has messages
    if (currentSession.messages.length > 0 && !currentSession.id) {
        currentSession.id = generateSessionId();
        currentSession.name = 'Unsaved Session';
        localStorage.setItem(`cogos-session-${currentSession.id}`, JSON.stringify(currentSession));
    }
    
    // Create new session
    currentSession = {
        id: generateSessionId(),
        name: sessionName,
        created: Date.now(),
        lastModified: Date.now(),
        messages: [],
        cogosVersion: "v2.4",
        activeModel: document.getElementById('default-model').value
    };
    
    // Clear chat and reinitialize
    chatContainer.innerHTML = '';
    addMessage('CogOS', `Cognitive Operating System initialized. Session: ${sessionName}. Ready for collaboration.`);
    
    document.getElementById('session-name').value = sessionName;
    updateSessionsList();
    updateSessionStatus(`New session "${sessionName}" created`);
}

function loadSelectedSession() {
    const sessionSelect = document.getElementById('session-list');
    const sessionId = sessionSelect.value;
    
    if (!sessionId) {
        alert('Please select a session to load');
        return;
    }
    
    const sessionData = localStorage.getItem(`cogos-session-${sessionId}`);
    if (!sessionData) {
        alert('Session not found');
        return;
    }
    
    currentSession = JSON.parse(sessionData);
    
    // Clear and rebuild chat
    chatContainer.innerHTML = '';
    currentSession.messages.forEach(msg => {
        addMessage(msg.sender, msg.content);
    });
    
    document.getElementById('session-name').value = currentSession.name;
    document.getElementById('default-model').value = currentSession.activeModel || 'deepseek';
    
    updateSessionStatus(`Session "${currentSession.name}" loaded`);
}

function deleteSelectedSession() {
    const sessionSelect = document.getElementById('session-list');
    const sessionId = sessionSelect.value;
    
    if (!sessionId) {
        alert('Please select a session to delete');
        return;
    }
    
    if (confirm('Are you sure you want to delete this session?')) {
        localStorage.removeItem(`cogos-session-${sessionId}`);
        updateSessionsList();
        updateSessionStatus('Session deleted');
    }
}

function clearCurrentSession() {
    if (confirm('Clear current conversation? (Unsaved changes will be lost)')) {
        chatContainer.innerHTML = '';
        currentSession.messages = [];
        addMessage('CogOS', 'Cognitive Operating System initialized. Ready for collaboration.');
        updateSessionStatus('Current session cleared');
    }
}

function exportSession() {
    if (currentSession.messages.length === 0) {
        alert('No messages to export');
        return;
    }
    
    const exportData = {
        ...currentSession,
        exportedAt: new Date().toISOString(),
        platform: 'CogOS Web Interface'
    };
    
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `cogos-session-${currentSession.name.replace(/[^a-z0-9]/gi, '_')}-${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);
    
    updateSessionStatus('Session exported');
}

function importSession(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const importedSession = JSON.parse(e.target.result);
            
            // Validate session structure
            if (!importedSession.messages || !importedSession.name) {
                throw new Error('Invalid session file format');
            }
            
            // Generate new ID to avoid conflicts
            importedSession.id = generateSessionId();
            importedSession.name = importedSession.name + ' (Imported)';
            
            // Save imported session
            localStorage.setItem(`cogos-session-${importedSession.id}`, JSON.stringify(importedSession));
            updateSessionsList();
            updateSessionStatus(`Session "${importedSession.name}" imported`);
            
        } catch (error) {
            alert('Error importing session: ' + error.message);
        }
    };
    reader.readAsText(file);
    
    // Reset file input
    event.target.value = '';
}

function updateSessionsList() {
    const sessionSelect = document.getElementById('session-list');
    sessionSelect.innerHTML = '<option value="">Select a session...</option>';
    
    // Get all saved sessions
    const sessions = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('cogos-session-')) {
            try {
                const session = JSON.parse(localStorage.getItem(key));
                sessions.push(session);
            } catch (e) {
                // Skip invalid sessions
            }
        }
    }
    
    // Sort by last modified (newest first)
    sessions.sort((a, b) => b.lastModified - a.lastModified);
    
    // Add to dropdown
    sessions.forEach(session => {
        const option = document.createElement('option');
        option.value = session.id;
        option.textContent = `${session.name} (${new Date(session.lastModified).toLocaleDateString()})`;
        sessionSelect.appendChild(option);
    });
}

function updateSessionStatus(message) {
    const statusDiv = document.getElementById('session-status');
    statusDiv.textContent = message;
    setTimeout(() => {
        statusDiv.textContent = '';
    }, 3000);
}

// Add message to chat with proper formatting and session tracking
function addMessage(sender, message, model = null) {
    const messageDiv = document.createElement('div');
    messageDiv.style.marginBottom = '15px';
    messageDiv.style.whiteSpace = 'pre-wrap';
    messageDiv.style.lineHeight = '1.4';
    messageDiv.innerHTML = `<strong>${sender}:</strong> ${message}`;
    chatContainer.appendChild(messageDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;
    
    // Add to session (except processing indicators)
    if (sender !== 'CogOS' || !message.includes('🤔')) {
        const messageObj = {
            sender: sender,
            content: message,
            timestamp: Date.now(),
            model: model
        };
        currentSession.messages.push(messageObj);
        currentSession.lastModified = Date.now();
    }
}

// Enhanced module detection
function checkForModules(message) {
    const lowerMessage = message.toLowerCase();
    let activeModules = [];
    
    // Check for all possible triggers
    if (lowerMessage.includes('!pump') || lowerMessage.includes('!hypothesize')) {
        activeModules.push(modules.pump);
    }
    if (lowerMessage.includes('!drill') || lowerMessage.includes('!analyze')) {
        activeModules.push(modules.drill);
    }
    if (lowerMessage.includes('!invert') || lowerMessage.includes('!counter')) {
        activeModules.push(modules.invert);
    }
    if (lowerMessage.includes('!checkpoint') || lowerMessage.includes('!cp')) {
        activeModules.push(modules.checkpoint);
    }
    if (lowerMessage.includes('!calibrate')) {
        activeModules.push(modules.calibrate);
    }
    if (lowerMessage.includes('!breach')) {
        activeModules.push(modules.breach);
    }
    if (lowerMessage.includes('!status')) {
        activeModules.push(modules.status);
    }
    if (lowerMessage.includes('/play') || lowerMessage.includes('/casual')) {
        activeModules.push(modules.play_mode);
    }
    if (lowerMessage.includes('/latentspace') || lowerMessage.includes('/associative')) {
        activeModules.push(modules.latentspace);
    }
    if (lowerMessage.includes('meta') || lowerMessage.includes('gremlin')) {
        activeModules.push(modules.comms_protocol);
        activeModules.push(modules.gremlins);
    }
    
    return activeModules;
}

// Send message function
async function sendMessage() {
    const message = messageInput.value.trim();
    if (!message) return;
    
    addMessage('You', message);
    messageInput.value = '';
    
    // Show thinking indicator
    addMessage('CogOS', '🤔 Processing...');
    
    try {
        // Check for active modules
        const activeModules = checkForModules(message);
        
        // Build system prompt with CogOS + active modules
        let systemPrompt = cogosCore;
        if (activeModules.length > 0) {
            systemPrompt += '\n\n' + activeModules.join('\n\n');
        }
// Add conversation context to system prompt (simple approach)
if (currentSession.messages.length > 0) {
    const recentMessages = currentSession.messages.slice(-6); // Last 6 messages
    let contextText = "\n\nCONVERSATION CONTEXT:\n";
    recentMessages.forEach(msg => {
        if (msg.sender !== 'CogOS' && !msg.content.includes('🤔')) {
            contextText += `${msg.sender}: ${msg.content}\n`;
        }
    });
    systemPrompt += contextText;
}        
        // Choose model
        const defaultModel = document.getElementById('default-model').value;
        currentSession.activeModel = defaultModel;
        let response;
        
        if (defaultModel === 'qwen') {
            response = await callQwen(message, systemPrompt);
        } else {
            response = await callDeepSeek(message, systemPrompt);
        }
        
        // Remove thinking indicator and add real response
        chatContainer.removeChild(chatContainer.lastChild);
        addMessage('AI', response, defaultModel);
        
    } catch (error) {
        // Remove thinking indicator and show error
        chatContainer.removeChild(chatContainer.lastChild);
        addMessage('Error', `Failed to get response: ${error.message}`);
    }
}

// Event listeners
sendButton.addEventListener('click', sendMessage);
messageInput.addEventListener('keypress', function(e) {
    if (e.key === 'Enter') sendMessage();
});

// Call this when page loads
window.onload = function() {
    loadSavedKeys();
    updateSessionsList();
    addMessage('CogOS', 'Cognitive Operating System initialized. Web V2.1 with Session Management. Ready for collaboration.');
};
</script>
</body>
</html>
